// Code generated by protoc-gen-go-aip-test. DO NOT EDIT.

package gomicroservicev1

import (
	context "context"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	proto "google.golang.org/protobuf/proto"
	protocmp "google.golang.org/protobuf/testing/protocmp"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	assert "gotest.tools/v3/assert"
	strings "strings"
	testing "testing"
	time "time"
)

// UserServiceTestSuiteConfigProvider is the interface to implement to decide which resources
// that should be tested and how it's configured.
type UserServiceTestSuiteConfigProvider interface {
	// UserServiceUser should return a config, or nil, which means that the tests will be skipped.
	UserServiceUser(t *testing.T) *UserServiceUserTestSuiteConfig
}

// testUserService is the main entrypoint for starting the AIP tests.
func testUserService(t *testing.T, s UserServiceTestSuiteConfigProvider) {
	testUserServiceUser(t, s)
}

func testUserServiceUser(t *testing.T, s UserServiceTestSuiteConfigProvider) {
	t.Run("User", func(t *testing.T) {
		config := s.UserServiceUser(t)
		if config == nil {
			t.Skip("Method UserServiceUser not implemented")
		}
		if config.Service == nil {
			t.Skip("Method UserServiceUser.Service() not implemented")
		}
		if config.Context == nil {
			config.Context = func() context.Context { return context.Background() }
		}
		config.test(t)
	})
}

type UserServiceTestSuite struct {
	T *testing.T
	// Server to test.
	Server UserServiceServer
}

func (fx UserServiceTestSuite) TestUser(ctx context.Context, options UserServiceUserTestSuiteConfig) {
	fx.T.Run("User", func(t *testing.T) {
		options.Context = func() context.Context { return ctx }
		options.Service = func() UserServiceServer { return fx.Server }
		options.test(t)
	})
}

type UserServiceUserTestSuiteConfig struct {
	currParent int

	// Service should return the service that should be tested.
	// The service will be used for several tests.
	Service func() UserServiceServer
	// Context should return a new context.
	// The context will be used for several tests.
	Context func() context.Context
	// Create should return a resource which is valid to create, i.e.
	// all required fields set.
	Create func() *User
	// IDGenerator should return a valid and unique ID to use in the Create call.
	// If non-nil, this function will be called to set the ID on all Create calls.
	// If the ID field is required, tests will fail if this is nil.
	IDGenerator func() string
	// Update should return a resource which is valid to update, i.e.
	// all required fields set.
	Update func() *User
	// Patterns of tests to skip.
	// For example if a service has a Get method:
	// Skip: ["Get"] will skip all tests for Get.
	// Skip: ["Get/persisted"] will only skip the subtest called "persisted" of Get.
	Skip []string
}

func (fx *UserServiceUserTestSuiteConfig) test(t *testing.T) {
	t.Run("Create", fx.testCreate)
	t.Run("Get", fx.testGet)
	t.Run("Update", fx.testUpdate)
	t.Run("List", fx.testList)
	t.Run("Delete", fx.testDelete)
}

func (fx *UserServiceUserTestSuiteConfig) testCreate(t *testing.T) {
	fx.maybeSkip(t)
	// Field create_time should be populated when the resource is created.
	t.Run("create time", func(t *testing.T) {
		fx.maybeSkip(t)
		beforeCreate := time.Now()
		userSetID := ""
		if fx.IDGenerator != nil {
			userSetID = fx.IDGenerator()
		}
		msg, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
			User:   fx.Create(),
			UserId: userSetID,
		})
		assert.NilError(t, err)
		assert.Check(t, msg.CreateTime != nil)
		assert.Check(t, !msg.CreateTime.AsTime().IsZero())
		assert.Check(t, msg.CreateTime.AsTime().After(beforeCreate), "msg.CreateTime (%v) is not after beforeCreate (%v)", msg.CreateTime.AsTime(), beforeCreate)
	})

	// The created resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		userSetID := ""
		if fx.IDGenerator != nil {
			userSetID = fx.IDGenerator()
		}
		msg, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
			User:   fx.Create(),
			UserId: userSetID,
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: msg.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, persisted, protocmp.Transform())
	})

	// If method support user settable IDs, when set the resource should
	// be returned with the provided ID.
	t.Run("user settable id", func(t *testing.T) {
		fx.maybeSkip(t)
		msg, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
			User:   fx.Create(),
			UserId: "usersetid",
		})
		assert.NilError(t, err)
		assert.Check(t, strings.HasSuffix(msg.GetName(), "usersetid"))
	})

	// Method should fail with InvalidArgument if the user settable id doesn't
	// conform to RFC-1034, see [doc](https://google.aip.dev/122#resource-id-segments).
	t.Run("invalid user settable id", func(t *testing.T) {
		fx.maybeSkip(t)
		for _, tt := range []struct {
			name string
			id   string
		}{
			{
				name: "start with digit",
				id:   "0foo",
			},
			{
				name: "start with hyphen",
				id:   "-foo",
			},
			{
				name: "start with non ascii letter",
				id:   "öfoo",
			},
			{
				name: "contains non ascii letter",
				id:   "fooöbar",
			},
			{
				name: "contains upper case ascii letter",
				id:   "fooBar",
			},
			{
				name: "ends with hyphen",
				id:   "foo-",
			},
			{
				name: "ends with non ascii",
				id:   "fooö",
			},
			{
				name: "too long",
				id:   "fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
			},
		} {
			t.Run(tt.name, func(t *testing.T) {
				fx.maybeSkip(t)
				_, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
					User:   fx.Create(),
					UserId: tt.id,
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
		}
	})

	// Method should fail with InvalidArgument if the user settable ID appears
	// to be a UUID, see [doc](https://google.aip.dev/122#resource-id-segments).
	t.Run("invalid user settable id - uuid", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
			User:   fx.Create(),
			UserId: "a3b950fb-ef42-4901-adc8-647ba02b5635",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// If method support user settable IDs and the same ID is reused
	// the method should return AlreadyExists.
	t.Run("already exists", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
			User:   fx.Create(),
			UserId: "alreadyexists",
		})
		assert.NilError(t, err)
		_, err = fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
			User:   fx.Create(),
			UserId: "alreadyexists",
		})
		assert.Equal(t, codes.AlreadyExists, status.Code(err), err)
	})

	// The method should fail with InvalidArgument if the resource has any
	// required fields and they are not provided.
	t.Run("required fields", func(t *testing.T) {
		fx.maybeSkip(t)
		t.Run(".display_name", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Create()
			container := msg
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
			container.ProtoReflect().Clear(fd)
			userSetID := ""
			if fx.IDGenerator != nil {
				userSetID = fx.IDGenerator()
			}
			_, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
				User:   msg,
				UserId: userSetID,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
		t.Run(".email", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Create()
			container := msg
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("email")
			container.ProtoReflect().Clear(fd)
			userSetID := ""
			if fx.IDGenerator != nil {
				userSetID = fx.IDGenerator()
			}
			_, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
				User:   msg,
				UserId: userSetID,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
	})

}

func (fx *UserServiceUserTestSuiteConfig) testGet(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be returned without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		msg, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, created, protocmp.Transform())
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		_, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: "users/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *UserServiceUserTestSuiteConfig) testUpdate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		msg := fx.Update()
		msg.Name = ""
		_, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
			User: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		msg := fx.Update()
		msg.Name = "invalid resource name"
		_, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
			User: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field update_time should be updated when the resource is updated.
	t.Run("update time", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		updated, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
			User: created,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.UpdateTime.AsTime().After(created.UpdateTime.AsTime()))
	})

	// The updated resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		updated, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
			User: created,
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetUser(fx.Context(), &GetUserRequest{
			Name: updated.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, updated, persisted, protocmp.Transform())
	})

	// The field create_time should be preserved when a '*'-update mask is used.
	t.Run("preserve create_time", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		originalCreateTime := created.CreateTime
		updated, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
			User: created,
			UpdateMask: &fieldmaskpb.FieldMask{
				Paths: []string{
					"*",
				},
			},
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, originalCreateTime, updated.CreateTime, protocmp.Transform())
	})

	{
		created := fx.create(t)
		// Method should fail with NotFound if the resource does not exist.
		t.Run("not found", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Update()
			msg.Name = created.Name + "notfound"
			_, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
				User: msg,
			})
			assert.Equal(t, codes.NotFound, status.Code(err), err)
		})

		// The method should fail with InvalidArgument if the update_mask is invalid.
		t.Run("invalid update mask", func(t *testing.T) {
			fx.maybeSkip(t)
			_, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
				User: created,
				UpdateMask: &fieldmaskpb.FieldMask{
					Paths: []string{
						"invalid_field_xyz",
					},
				},
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})

		// Method should fail with InvalidArgument if any required field is missing
		// when called with '*' update_mask.
		t.Run("required fields", func(t *testing.T) {
			fx.maybeSkip(t)
			t.Run(".display_name", func(t *testing.T) {
				fx.maybeSkip(t)
				msg := proto.Clone(created).(*User)
				container := msg
				if container == nil {
					t.Skip("not reachable")
				}
				fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
				container.ProtoReflect().Clear(fd)
				_, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
					User: msg,
					UpdateMask: &fieldmaskpb.FieldMask{
						Paths: []string{
							"*",
						},
					},
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
			t.Run(".email", func(t *testing.T) {
				fx.maybeSkip(t)
				msg := proto.Clone(created).(*User)
				container := msg
				if container == nil {
					t.Skip("not reachable")
				}
				fd := container.ProtoReflect().Descriptor().Fields().ByName("email")
				container.ProtoReflect().Clear(fd)
				_, err := fx.Service().UpdateUser(fx.Context(), &UpdateUserRequest{
					User: msg,
					UpdateMask: &fieldmaskpb.FieldMask{
						Paths: []string{
							"*",
						},
					},
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
		})

	}
}

func (fx *UserServiceUserTestSuiteConfig) testList(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument is provided page token is not valid.
	t.Run("invalid page token", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().ListUsers(fx.Context(), &ListUsersRequest{
			PageToken: "invalid page token",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page size is negative.
	t.Run("negative page size", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().ListUsers(fx.Context(), &ListUsersRequest{
			PageSize: -10,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *UserServiceUserTestSuiteConfig) testDelete(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be deleted without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		_, err := fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		_, err := fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with NotFound if the resource was already deleted. This also applies to soft-deletion.
	t.Run("already deleted", func(t *testing.T) {
		fx.maybeSkip(t)
		created := fx.create(t)
		deleted, err := fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		_ = deleted
		_, err = fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: created.Name,
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteUser(fx.Context(), &DeleteUserRequest{
			Name: "users/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *UserServiceUserTestSuiteConfig) maybeSkip(t *testing.T) {
	for _, skip := range fx.Skip {
		if strings.Contains(t.Name(), skip) {
			t.Skip("skipped because of .Skip")
		}
	}
}

func (fx *UserServiceUserTestSuiteConfig) create(t *testing.T) *User {
	t.Helper()
	userSetID := ""
	if fx.IDGenerator != nil {
		userSetID = fx.IDGenerator()
	}
	created, err := fx.Service().CreateUser(fx.Context(), &CreateUserRequest{
		User:   fx.Create(),
		UserId: userSetID,
	})
	assert.NilError(t, err)
	return created
}
